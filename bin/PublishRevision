#!/bin/sh

### Imports ###################################################################

source ScriptFunctions
Import GoboLinux
Import File
Import Subversion
Import OptionParser

### Options ###################################################################

scriptDescription="Publish a revision from the svn trunk to the revisions tree."
scriptCredits="Copyright (C) 2006 Hisham Muhammad. Released under the GNU GPL."
helpOnNoArguments=yes
scriptUsage="<program> [<version>]"
scriptExample="Glibc 2.5"
scriptNotes="If no version is given, all versions in trunk are checked."
Add_Option_Boolean "S" "skip-lint" "Don't run RecipeLint."
Add_Option_Boolean "b" "batch" "Don't ask questions. Generate automatic commit logs such as 'NewVersion' and 'New recipe'."
#Add_Option_Entry "r" "rename" "Rename program to <entry>."
#Add_Option_List "l" "list" "Enter a colon-separated list of..." "foo:bar"
Add_Option_Entry "u" "username"  "User name used for committing changes at svn server."
Parse_Options "$@"

# Use this to parse attributions from
# ${goboSettings}/Scripts/INSERT_NAME_HERE.conf or
# ${goboUserSettings}/Scripts/INSERT_NAME_HERE.conf 

Parse_Conf CompileSubversion.conf
Parse_Conf Compile/Compile.conf

unset batch
Boolean "batch" && batch=yes

username=`Entry username`
[ "$username" ] && username="--username $username" 

### Operation #################################################################

function publish_revision() {
   program="$1"
   version="$2"
   
   if ! [ -d "$revisions/$program" ]
   then
      svn mkdir "$revisions/$program"
   fi
   prefix="$version-r"
   if ls -d "$revisions/$program/$prefix"* &> /dev/null
   then
      latest=`cd "$revisions/$program"; ls -d "$prefix"* | cut -b$[${#prefix}+1]- | sort -nr | head -n1`
      revision=$[latest+1]
      
      if [ `diff -Nur --exclude .svn "$revisions/$program/$version-r$latest" "$trunk/$program/$version" | wc -l` = 0 ]
      then
         Log_Verbose "There are no differences between the trunk and the latest revision (r$latest)."
         Log_Verbose "Will not publish a new revision for $program $version."
         return
      fi
      commitmsg="NewVersion."
   else
      revision=1
      commitmsg="New recipe."
   fi
   
   appdir="$trunk/$program/$version"
   if [ `svn status "$appdir" | wc -l` -gt 0 ]
   then
      Log_Normal "Trunk has uncommitted changes for $program $version."
      if [ `ls "$trunk/$program" | wc -l` -eq 1 ]
      then commitdir="$trunk/$program"
      else commitdir="$appdir"
      fi
      if [ "$batch" ]
      then svn commit -m "$commitmsg" $username "$commitdir" || Die "Error committing $commitdir"
      elif Ask "Commit the changes at $commitdir?"
      then svn commit $username "$commitdir" || Die "Error committing $commitdir"
      else return
      fi
   fi
   
   Log_Normal "Publishing revision: $program $version-r$revision"

   unset publishrecipe
   recipetarball="$goboTemp/$program--$version--recipe.tar.bz2"
   (
      cd "$trunk"
      Verbose tar cjvpf "$recipetarball" --exclude=.svn "$program/$version"
   )

   if ! Boolean "skip-lint"
   then
      RecipeLint "$recipetarball"
      recipestatus=$?
      rm "$recipetarball"
      if [ "$recipestatus" -eq 1 ]
      then
         Log_Error "RecipeLint reported warnings in $program $version from trunk."
         if ! Ask "Proceed and publish it anyway?"
         then return
         fi
         publishrecipe=yes
      elif [ "$recipestatus" -eq 2 ]
      then
         Log_Error "RecipeLint reported errors in $program $version from trunk. Not publishing it."
         return
      fi
   fi

   svn copy "$appdir" "$revisions/$program/$version-r$revision"
   
   if [ `ls "$revisions/$program" | wc -l` -eq 1 ]
   then revdir="$revisions/$program"
   else revdir="$revisions/$program/$version-r$revision"
   fi
   
   Log_Normal "Listing $revdir"
   find $revdir | grep -v '\.svn'
   if [ ! "$publishrecipe" ] && [ ! "$batch" ] && ! Ask "Ok to commit revision?"
   then 
      # svn revert $revdir ?
      rm -rf $revdir
      return
   fi
   
   Log_Normal "Committing..."
   svn commit $username --message "Committing revision $revision" $revdir
}

### Operation #################################################################

program="$(basename $(Arg 1))"
version="$(Arg 2)"

trunk=`Get_Local_Trunk` || Die "Could not find a valid svn trunk."

programintrunk=`ls "$trunk" | grep -i "^$program$"`
[ "$programintrunk" ] || echo "Could not find $program in trunk."
[ `echo "$programintrunk" | wc -l` -eq 1 ] || Die "More than one capitalization for $program found in trunk. Please check."
program="$programintrunk"

unset checkedout
if ! revisions=`Get_Local_Revisions`
then 
   if Ask "You don't seem to have a copy of the svn revisions tree. Fetch it?"
   then
      Log_Normal "Calling 'svn checkout'."
      Quiet pushd $compileDir
      mkdir -p Subversion
      cd Subversion
      svn checkout --non-recursive $compileSubversion/revisions || Die "Error doing the svn checkout."
      Quiet popd
      Log_Normal "Checkout finished."
      checkedout=yes
   fi
   if ! revisions=`Get_Local_Revisions` || [ ! "$checkedout" ]
   then Die "Could not find a valid svn revisions tree."
   fi
fi

existingprogram=`ls "$revisions" 2> /dev/null | grep -i "^$program$"`
if [ ! "$existingprogram" ]
then
   Log_Normal "Trying to checkout $program..."
   Quiet pushd $revisions
   svn checkout "$compileSubversion/revisions/$program"
   Quiet popd
   checkedout=yes
fi

if [ ! "`ls "$trunk/$program"`" ]
then
   Log_Normal "No versions in trunk. Checking out..."
   Quiet pushd $trunk
   svn checkout "$compileSubversion/trunk/$program"
   Quiet popd
fi

if [ ! "$checkedout" = "yes" ]
then
   Log_Normal "Updating local subversion copy..."
   svn update "$revisions/$program"
fi

if [ "$version" ]
then
   publish_revision "$program" "$version"
else
   for version in `ls "$trunk/$program"`
   do
      publish_revision "$program" $(basename "$version")
   done
fi
