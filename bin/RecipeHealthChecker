#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Checks the health of recipes by validating their url(s).
# Written by Lucas C. Villa Real
# Released under the GPL version 2

from multiprocessing import Pool, cpu_count
from itertools import repeat
import subprocess
import configparser
import hashlib
import glob
import sys

import os
import socket
import http.client as httplib
import urllib.request as urllib2
import contextlib

# Set default timeout
socket.setdefaulttimeout(60)

class URI:
	''' Interface for downloading files via HTTP or FTP protocols '''
	def __init__(self, uri=''):
		self.uri = uri
		self.opener = urllib2.build_opener()

	def validate(self, filesize=-1, filemd5=""):
		numread, blob, checksum = 0, bytes(), hashlib.md5()
		try:
			with contextlib.closing(self.opener.open(self.uri)) as u:
				if filesize >= 0 and u.info().get('Content-Length'):
					contentlength = int(u.info().get('Content-Length'))
					return filesize == contentlength
				while True:
					data = u.read(8192)
					if len(data) == 0:
						break
					blob += data
					numread += len(data)
			checksum.update(blob)
		except httplib.IncompleteRead as e:
			blob += e.partial
			numread += len(e.partial)
			checksum.update(blob)
		except urllib2.HTTPError as e:
			#print("HTTP error submitting request: {}".format(e.code))
			return e.code
		except urllib2.URLError as e:
			#print("URL error submitting request: {}".format(e.reason))
			return False
		except socket.error as e:
			#print("URL error submitting request: {}".format(e))
			return False
		except ValueError as e:
			#print("URL error submitting request: {}".format(e))
			return False

		if filesize >= 0:
			return filesize == numread
		elif len(filemd5) and numread > 0:
			return filemd5 == checksum.hexdigest()
		elif numread > 0:
			return Magic(blob).isArchive()
		return False


class Magic:
	''' Attempts to validate an archive by looking at its first few bytes '''
	def __init__(self, blob):
		self.blob = blob

	def isArchive(self):
		p = subprocess.Popen(["file", "--brief", "-"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
		stdout, stderr = p.communicate(self.blob)
		return True if not b"HTML document" in stdout else False


class VersionControl:
	def __init__(self, repos):
		self.repos = repos

	def do_validate(self, cmd, environ=None):
		if not which(cmd[0]):
			return True
		if environ is None:
			environ = os.environ.copy()
		p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=environ)
		for line in p.stdout:
			pass
		p.wait()
		return p.returncode == 0


class CVS(VersionControl):
	def __init__(self, repos, module):
		VersionControl.__init__(self, repos)
		self.module = module if module is not None else os.path.basename(self.repos)

	def validate(self):
		cmd = ["cvs", "-Q", "--no-verify", "-z3", "-d{}".format(self.repos), "co", "-p", self.module]
		return self.do_validate(cmd)


class SVN(VersionControl):
	def validate(self):
		cmd = ["svn", "ls", self.repos]
		return self.do_validate(cmd)


class GIT(VersionControl):
	def validate(self):
		cmd = ["git", "ls-remote", self.repos]
		environ = os.environ.copy()
		environ["GIT_SSL_NO_VERIFY"] = "true"
		return self.do_validate(cmd, environ)


class BZR(VersionControl):
	def validate(self):
		cmd = ["bzr", "info", self.repos]
		return self.do_validate(cmd)


class HG(VersionControl):
	def validate(self):
		cmd = ["hg", "identify", self.repos]
		return self.do_validate(cmd)


class RecipeList:
	def __init__(self):
		self.ignore = []

	def update(self):
		''' Populate or update /Data/Compile/Git/Recipes '''
		subprocess.call(["CheckoutRecipe","--batch","GCC"])

	def exclude(self, pdict):
		for key in pdict.keys():
			for val in pdict[key]:
				self.ignore.append("/Data/Compile/Git/Recipes/trunk/{0}/{1}".format(key, val))

	def __valid(self, path):
		return True if path not in self.ignore else False

	def get(self):
		''' Get a list of all recipe directories '''
		recipes = glob.glob("/Data/Compile/Git/Recipes/trunk/*/*")
		return list(filter(self.__valid, recipes))


class Recipe:
	def __init__(self, recipedir, cp):
		self.recipedir = recipedir
		self.program = os.path.basename(os.path.dirname(recipedir))
		self.version = os.path.basename(recipedir)
		self.cp = cp
		self.cvs = None
		self.cvs_module = None
		self.svn = None
		self.git = None
		self.bzr = None
		self.hg = None
		self.urls = []
		self.md5s = []
		self.sizes = []

	def tarballInfo(self):
		urls, sizes, md5s = self.urls, self.sizes, self.md5s
		if len(sizes) < len(urls):
			sizes = [-1] * len(urls)
		if len(md5s) < len(urls):
			md5s = [""] * len(urls)
		return urls, sizes, md5s

	def parse(self):
		''' Parses all recipe files of a given directory '''
		recipes = ["{}/Recipe".format(self.recipedir)] + glob.glob("{}/*/Recipe".format(self.recipedir))
		for recipe in recipes:
			self.__parse(recipe)

	def __parse(self, recipe):
		''' A naive Recipe parser '''
		try:
			data = str(open(recipe, "rb").read())
		except UnicodeDecodeError as e:
			print("Error parsing {0}".format(recipe))
			raise

		data = data.replace("$ftpGnu", self.cp.get("main", "ftpGnu"))
		data = data.replace("${ftpGnu}", self.cp.get("main", "ftpGnu"))
		data = data.replace("$ftpAlphaGnu", self.cp.get("main", "ftpAlphaGnu"))
		data = data.replace("${ftpAlphaGnu}", self.cp.get("main", "ftpAlphaGnu"))
		data = data.replace("$httpSourceforge", self.cp.get("main", "httpSourceforge"))
		data = data.replace("${httpSourceforge}", self.cp.get("main", "httpSourceforge"))

		if data.find("url=") >= 0:
			self.urls = [self.__parseKey(data, "url=")]
		elif data.find("urls=") >= 0:
			self.urls = self.__parseList(data, "urls=")
		elif data.find("cvs=") >= 0:
			self.cvs = self.__parseKey(data, "cvs=")
		elif data.find("cvs_module=") >= 0:
			self.cvs_module = self.__parseKey(data, "cvs_module=")
		elif data.find("svn=") >= 0:
			self.svn = self.__parseKey(data, "svn=")
		elif data.find("git=") >= 0:
			self.git = self.__parseKey(data, "git=")
		elif data.find("bzr=") >= 0:
			self.bzr = self.__parseKey(data, "bzr=")
		elif data.find("hg=") >= 0:
			self.hg = self.__parseKey(data, "hg=")

		if data.find("file_md5=") >= 0:
			self.md5s = [self.__parseKey(data, "file_md5=")]
		elif data.find("file_md5s=") >= 0:
			self.md5s = self.__parseList(data, "file_md5s=")

		if data.find("file_size=") >= 0:
			self.sizes = [int(x) for x in [self.__parseKey(data, "file_size=")]]
		elif data.find("file_sizes=") >= 0:
			self.sizes = [int(x) for x in self.__parseList(data, "file_sizes=")]

	def __parseKey(self, data, key):
		# We escape \n because the file is read in binary mode (rb)
		start = data.find(key)
		end = start + data[start:].find("\\n")
		return data[start:end].split("=")[1].strip('"').strip("'")

	def __parseList(self, data, key):
		# We escape \n because the file is read in binary mode (rb)
		start = data.find(key)
		end = start + data[start:].find(")")
		substr = data[start:end].replace(key, "").replace("(", "")
		return [x.strip().strip('"').strip("'") for x in substr.split("\\n") if len(x)]


def which(app):
	fpath, fname = os.path.split(app)
	if fpath and os.path.isfile(app) and os.access(app, os.X_OK):
		return app
	elif not fpath:
		for entry in os.environ['PATH'].split(os.pathsep):
			entry = entry.strip('"')
			execFile = os.path.join(entry, app)
			if os.path.isfile(execFile) and os.access(execFile, os.X_OK):
				return execFile
	return None


def readline_generator(fp):
	''' Translates a GoboLinux config file into an INI file '''
	line = fp.readline()
	yield "[main]\n"
	while line:
		if line == "(\n" or line == ")\n":
			yield "\n"
		else:
			yield line
		line = fp.readline()


def health_check(recipedir, cp, logfile):
	''' Checks the health of a recipe '''
	r = Recipe(recipedir, cp)
	r.parse()
	if len(r.urls):
		urls, sizes, md5s = r.tarballInfo()
		for url, size, md5 in zip(urls, sizes, md5s):
			status = URI(url).validate(size, md5)
			write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, url, status), logfile)
	elif r.cvs:
		status = CVS(r.cvs, r.cvs_module).validate()
		write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, r.cvs, status), logfile)
	elif r.svn:
		status = SVN(r.svn).validate()
		write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, r.svn, status), logfile)
	elif r.git:
		status = GIT(r.git).validate()
		write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, r.git, status), logfile)
	elif r.bzr:
		status = BZR(r.bzr).validate()
		write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, r.bzr, status), logfile)
	elif r.hg:
		status = HG(r.hg).validate()
		write_health_log("{0} {1} {2} {3}\n".format(r.program, r.version, r.hg, status), logfile)


def write_health_log(data, logfile):
	sys.stdout.write(data)
	with open(logfile, "a") as f:
		f.write(data)


def read_health_log(fname):
	try:
		pairs = [(x.split()[0], x.split()[1]) for x in open(fname).readlines()]
		pdict = dict([(x[0],[]) for x in pairs])
		for key, val in pairs:
			pdict[key].append(val)
		return pdict
	except:
		return dict()


def main():
	if not which("cvs"):
		print("Warning: cvs executable not found, assuming all CVS recipes good")
	if not which("svn"):
		print("Warning: svn executable not found, assuming all SVN recipes good")
	if not which("git"):
		print("Warning: git executable not found, assuming all GIT recipes good")
	if not which("bzr"):
		print("Warning: bzr executable not found, assuming all BZR recipes good")
	if not which("hg"):
		print("Warning: hg executable not found, assuming all HG recipes good")

	cp = configparser.ConfigParser()
	cp.read_file(readline_generator(open("/System/Settings/Compile/Compile.conf")))

	logfile = "health.log"
	recipelist = RecipeList()
	recipelist.update()
	recipelist.exclude(read_health_log(logfile))

	with Pool(cpu_count()) as pool:
		pool.starmap(health_check, zip(recipelist.get(), repeat(cp), repeat(logfile)))


if __name__ == "__main__":
    main()

# vim: noexpandtab tabstop=4 shiftwidth=4:
