#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Checks the health of recipes by validating their url(s).
# Written by Lucas C. Villa Real
# Released under the GPL version 2

from multiprocessing import Pool, cpu_count
from itertools import repeat
import subprocess
import configparser
import glob
import hashlib

import os
import socket
import http.client as httplib
import urllib.request as urllib2
import contextlib

# Set default timeout
socket.setdefaulttimeout(60)

# Patch httplib to recover from errors like:
#
#  File "/usr/lib64/python2.7/socket.py", line 380, in read
#    data = self._sock.recv(left)
#  File "/usr/lib64/python2.7/httplib.py", line 541, in read
#    return self._read_chunked(amt)
#  File "/usr/lib64/python2.7/httplib.py", line 592, in _read_chunked
#    value.append(self._safe_read(amt))
#  File "/usr/lib64/python2.7/httplib.py", line 649, in _safe_read
#    raise IncompleteRead(''.join(s), amt)
#  httplib.IncompleteRead: IncompleteRead(2519 bytes read, 1961 more expected)

def http_response_read(func):
	def inner(*args):
		try:
			return func(*args)
		except httplib.IncompleteRead as e:
			return e.partial
	return inner

httplib.HTTPResponse.read = http_response_read(httplib.HTTPResponse.read)


class URI:
	''' Interface for downloading files via HTTP or FTP protocols '''
	def __init__(self, uri=''):
		self.uri = uri
		self.opener = urllib2.build_opener()

	def validate(self, filesize=-1, filemd5=""):
		numread, blob, checksum = 0, bytes(), hashlib.md5()
		try:
			with contextlib.closing(self.opener.open(self.uri)) as u:
				if filesize >= 0 and u.info().get('Content-Length'):
					contentlength = int(u.info().get('Content-Length'))
					return filesize == contentlength
				while True:
					data = u.read(8192)
					if len(data) == 0:
						break
					blob += data
					numread += len(data)
			checksum.update(blob)
		except urllib2.HTTPError as e:
			#print("HTTP error submitting request: {}".format(e.code))
			return False
		except urllib2.URLError as e:
			#print("URL error submitting request: {}".format(e.reason))
			return False
		except socket.error as e:
			#print("URL error submitting request: {}".format(e))
			return False

		if filesize >= 0:
			return filesize == numread
		elif len(filemd5) and numread > 0:
			return filemd5 == checksum.hexdigest()
		elif numread > 0:
			return Magic(blob).isArchive()
		return False


class Magic:
	''' Attempts to validate an archive by looking at its first few bytes '''
	def __init__(self, blob):
		self.blob = blob

	def isArchive(self):
		p = subprocess.Popen(["file", "--brief", "-"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
		stdout, stderr = p.communicate(self.blob)
		return True if not b"HTML document" in stdout else False


class VersionControl:
	def __init__(self, repos):
		self.repos = repos

	def do_validate(self, cmd, environ=None):
		if not which(cmd[0]):
			return True
		if environ is None:
			environ = os.environ.copy()
		p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=environ)
		for line in p.stdout:
			pass
		p.wait()
		return p.returncode == 0


class CVS(VersionControl):
	def __init__(self, repos, module):
		VersionControl.__init__(repos)
		self.module = module if module is not None else os.path.basename(self.repos)

	def validate(self):
		cmd = ["cvs", "-Q", "--no-verify", "-z3", "-d{}".format(self.repos), "co", "-p", self.module]
		return self.do_validate(cmd)


class SVN(VersionControl):
	def validate(self):
		cmd = ["svn", "ls", self.repos]
		return self.do_validate(cmd)


class GIT(VersionControl):
	def validate(self):
		cmd = ["git", "ls-remote", self.repos]
		environ = os.environ.copy()
		environ["GIT_SSL_NO_VERIFY"] = "true"
		return self.do_validate(cmd, environ)


class BZR(VersionControl):
	def validate(self):
		cmd = ["bzr", "info", self.repos]
		return self.do_validate(cmd)


class HG(VersionControl):
	def validate(self):
		cmd = ["hg", "identify", self.repos]
		return self.do_validate(cmd)


class RecipeList:
	def update(self):
		''' Populate or update /Data/Compile/Git/Recipes '''
		subprocess.call(["CheckoutRecipe","--batch","GCC"])

	def get(self, which="trunk"):
		''' Get a list of all recipe directories '''
		return glob.glob("/Data/Compile/Git/Recipes/{}/*/*".format(which))


class Recipe:
	def __init__(self, recipedir, cp):
		self.recipedir = recipedir
		self.program = os.path.basename(os.path.dirname(recipedir))
		self.version = os.path.basename(recipedir)
		self.cp = cp
		self.cvs = None
		self.cvs_module = None
		self.svn = None
		self.git = None
		self.bzr = None
		self.hg = None
		self.urls = []
		self.md5s = []
		self.sizes = []

	def tarballInfo(self):
		urls, sizes, md5s = self.urls, self.sizes, self.md5s
		if len(sizes) < len(urls):
			sizes = [-1] * len(urls)
		if len(md5s) < len(urls):
			md5s = [""] * len(urls)
		return urls, sizes, md5s

	def parse(self):
		''' Parses all recipe files of a given directory '''
		recipes = ["{}/Recipe".format(self.recipedir)] + glob.glob("{}/*/Recipe".format(self.recipedir))
		for recipe in recipes:
			self.__parse(recipe)

	def __parse(self, recipe):
		''' A naive Recipe parser '''
		try:
			data = str(open(recipe, "rb").read())
		except UnicodeDecodeError as e:
			print("Error parsing {0}".format(recipe))
			raise

		data = data.replace("$ftpGnu", self.cp.get("main", "ftpGnu"))
		data = data.replace("$ftpAlphaGnu", self.cp.get("main", "ftpAlphaGnu"))
		data = data.replace("$httpSourceforge", self.cp.get("main", "httpSourceforge"))

		if data.find("url=") >= 0:
			self.urls = [self.__parseKey(data, "url=")]
		elif data.find("urls=") >= 0:
			self.urls = self.__parseList(data, "urls=")
		elif data.find("cvs=") >= 0:
			self.cvs = self.__parseKey(data, "cvs=")
		elif data.find("cvs_module=") >= 0:
			self.cvs_module = self.__parseKey(data, "cvs_module=")
		elif data.find("svn=") >= 0:
			self.svn = self.__parseKey(data, "svn=")
		elif data.find("git=") >= 0:
			self.git = self.__parseKey(data, "git=")
		elif data.find("bzr=") >= 0:
			self.bzr = self.__parseKey(data, "bzr=")
		elif data.find("hg=") >= 0:
			self.hg = self.__parseKey(data, "hg=")

		if data.find("file_md5=") >= 0:
			self.md5s = [self.__parseKey(data, "file_md5=")]
		elif data.find("file_md5s=") >= 0:
			self.md5s = self.__parseList(data, "file_md5s=")

		if data.find("file_size=") >= 0:
			self.sizes = [int(x) for x in [self.__parseKey(data, "file_size=")]]
		elif data.find("file_sizes=") >= 0:
			self.sizes = [int(x) for x in self.__parseList(data, "file_sizes=")]

	def __parseKey(self, data, key):
		# Note the escaped \n due to the way we read the file
		start = data.find(key)
		end = start + data[start:].find("\\n")
		return data[start:end].split("=")[1].strip('"').strip("'")

	def __parseList(self, data, key):
		# Note the escaped \n due to the way we read the file
		start = data.find(key)
		end = start + data[start:].find(")")
		substr = data[start:end].replace(key, "").replace("(", "")
		return [x.strip().strip('"').strip("'") for x in substr.split("\\n") if len(x)]


def which(app):
	fpath, fname = os.path.split(app)
	if fpath and os.path.isfile(app) and os.access(app, os.X_OK):
		return app
	elif not fpath:
		for entry in os.environ['PATH'].split(os.pathsep):
			entry = entry.strip('"')
			execFile = os.path.join(entry, app)
			if os.path.isfile(execFile) and os.access(execFile, os.X_OK):
				return execFile
	return None


def readline_generator(fp):
	''' Translates a GoboLinux config file into an INI file '''
	line = fp.readline()
	yield "[main]\n"
	while line:
		if line == "(\n" or line == ")\n":
			yield "\n"
		else:
			yield line
		line = fp.readline()


def health_check(recipedir, cp):
	''' Checks the health of a recipe '''
	r = Recipe(recipedir, cp)
	r.parse()
	if len(r.urls):
		urls, sizes, md5s = r.tarballInfo()
		for url, size, md5 in zip(urls, sizes, md5s):
			ok = URI(url).validate(size, md5)
			print("{0} {1}, {2}: {3}".format(r.program, r.version, url, ok))
	elif r.cvs:
		ok = CVS(r.cvs, r.cvs_module).validate()
		print("{0} {1}: {2}: {3}".format(r.program, r.version, r.cvs, ok))
	elif r.svn:
		ok = SVN(r.svn).validate()
		print("{0} {1}: {2}: {3}".format(r.program, r.version, r.svn, ok))
	elif r.git:
		ok = GIT(r.git).validate()
		print("{0} {1}: {2}: {3}".format(r.program, r.version, r.git, ok))
	elif r.bzr:
		ok = BZR(r.bzr).validate()
		print("{0} {1}: {2}: {3}".format(r.program, r.version, r.bzr, ok))
	elif r.hg:
		ok = HG(r.hg).validate()
		print("{0} {1}: {2}: {3}".format(r.program, r.version, r.hg, ok))


def main():
	if not which("cvs"):
		print("Warning: cvs executable not found, assuming all CVS recipes good")
	if not which("svn"):
		print("Warning: svn executable not found, assuming all SVN recipes good")
	if not which("git"):
		print("Warning: git executable not found, assuming all GIT recipes good")
	if not which("bzr"):
		print("Warning: bzr executable not found, assuming all BZR recipes good")
	if not which("hg"):
		print("Warning: hg executable not found, assuming all HG recipes good")

	cp = configparser.ConfigParser()
	cp.read_file(readline_generator(open("/System/Settings/Compile/Compile.conf")))

	recipelist = RecipeList()
	recipelist.update()

	with Pool(cpu_count()) as pool:
		pool.starmap(health_check, zip(recipelist.get(), repeat(cp)))


if __name__ == "__main__":
    main()

# vim: noexpandtab tabstop=4 shiftwidth=4:
